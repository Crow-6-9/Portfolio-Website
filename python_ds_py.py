# -*- coding: utf-8 -*-
"""python ds .py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gL8i0nVEcT2zAVrCvw4hxlaXPxIoLng6
"""

class node:
  def __init__(self,data):
    self.data=data
    self.next=None

class linkedlist:
  def __init__(self):
    self.head=None

  def insert_at_end(self,data):
    newnode=node(data)
    if self.head is None:
      self.head=newnode
      return
    lastnode=self.head
    while lastnode.next:
      lastnode=lastnode.next
    lastnode.next=newnode

    #insert at begining

  def insert_at_begg(self,data):
    newnode=node(data)
    newnode.next=self.head
    self.head=newnode


  def delete(self,key):
    current=self.head
    prev=None
    if current and current.data==key:
      self.head=current.next
      current=None
      return

    while current and current.data!=key:
      prev=current
      current=current.next

    if current is None:
      print("node not found ")

    prev.next=current.next
    current=None

  def  reverse(self):
    prev=None
    current=self.head
    while current:
      nextnode=current.next
      current.next=prev
      prev=current
      current=nextnode
    self.head=prev


  def display(self):
    current=self.head
    if not current:
      print("LL is empty")
      return
    while current:
      print(current.data, end="--->")
      current=current.next
    print("none")

l=linkedlist()
l.insert_at_end(11)
l.insert_at_end(13)
l.insert_at_end(24)
l.insert_at_end(56)
l.display()

l.insert_at_begg(55)
l.display()

l.reverse()

l.display()

class node:
  def __init__(self,data):
    self.data=data
    self.prev=None
    self.next=None

class Doublyll:
  def __init__(self) :
    self.head=None

  def insert_at_end(self,data):
    newnode=node(data)
    if self.head is None:
      self.head=newnode
      return

    lastnode=self.head
    while lastnode.next:
      lastnode=lastnode.next
    lastnode.next=newnode
    newnode.prev=lastnode

  def display(self):
    if self.head is None:
      print("DLL is emmpty")
      return
    current=self.head
    while current:
      print(current.data,end="<-->" if current.next else "")
      current=current.next

dll=Doublyll()
dll.insert_at_end(11)
dll.insert_at_end(22)
dll.insert_at_end(45)
dll.insert_at_end(17)
dll.insert_at_end(13)
dll.display()

#paranthesis ques

def isbalance(s):

  stack=[]
  brackets={
      ")":"(", "}":"{","]":"["
  }

  for char in s:
    if char in  brackets.values():
      stack.append(char)
    elif char in brackets.keys():
      if stack==[] or stack.pop()!=brackets[char]:
        return False

  return stack==[]
s="{[()]}"
print(isbalance(s))

# q=[2,3,5,4,6]


class queue:
  def __init__(self):
    self.queue=[]

  def enqueue(self,item):
    self.queue.append(item)

  def dequeue(self):
    if not self.is_empty():
      return self.queue.pop(0)
    else:
      print("Queue is empty")

  def peek(self):
    if not self.is_empty():
      return self.queue[0]
    else:
      print("queeue is empty")

  def is_empty(self):
    return len(self.queue)==0

  def display(self):
    return self.queue

q=queue()
q.enqueue(3)
q.enqueue(8)
q.enqueue(6)
q.enqueue(4)
q.enqueue(11)
q.enqueue(9)

print(q.peek())
q.display()

"""**sorting algos**

"""

'''
sorting    bestcase    averagecase     worstcase
bubble      O(m)          O(m**2)        O(n**2)
selection   O(n**2)       O(n**2)         O(n**2)
insertion   O(n)          O(n**2)       O(n**2)
merge       O(nlogn)      O(nlogn)       O(nlogn)
quick       O(nlogn)      O(nlogn)       O(n**2)
heap        O(nlogn)      O(nlogn)       O(nlogn)
'''

"""**Sorting techniques**

**`Bubble sort`**
"""

def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if swapped==False :
            break
    return arr

bb = [33, 24, 78, 17, 3, 26]
print(bubble_sort(bb))

"""***selection sort***

"""

def selection_sort(arr):
  n=len(arr)
  for i in range (n):
    m_index=i
    for j in range(i+1,n):
      if arr[j]<arr[m_index]:
        m_index=j
    arr[i],arr[m_index]=arr[m_index],arr[i]

ss=[77,23,7,16,34]
selection_sort(ss)
print(ss)

"""**`Insertion sort`**"""

def insertionsort(arr):
  len(arr)
  for i in range (1,len(arr)):
    key=arr[i]

    j=i-1
    while j>=0 and key<arr[j]:
      arr[j+1]=arr[j]
      j-=1
    arr[j+1]=key
ins=[7,3,12,9,34,22,55,37]
insertionsort(ins)
print(ins)

'''Subarray with given sum
2
5 12
1 2 3 7 5
10 15
1 2 3 4 5 6 7 8 9 10
Output:
2 4
1 5
Explanation :
Testcase1: sum of elements from 2nd position to 4th position is 12
Testcase2: sum of elements from 1st position to 5th position is 15'''
def subarr(arr, n, s):
    for i in range(n):
        current_sum = 0
        for j in range(i, n):
            current_sum += arr[j]
            if current_sum == s:
                print(i + 1, j + 1)
                return
            elif current_sum > s:
                break
    print(-1)

arr = [1, 2, 3, 7, 5]
subarr(arr, len(arr), 12)

'''.Maximum Index
Given an array A[] of N positive integers. The task is to find t
maximum of j - is subjected to the constraint of A[i] <= A[j].
'''
arr=[1,9,34, 8, 10 ,3, 2, 80, 30, 33, 1]
def max_index(arr,n):
  max_diff=0
  for i in range (n):
    for j in range(1,n):
      if arr[i]<=arr[j]:
          max_diff=max(max_diff,j-i)
      return  max_diff
max_index(arr,len(arr))

arr=[1,2,3,2,1,4]

def missing_unique(arr,n):
  u=set()
  for i in range (len(arr)):
    if arr.count(i)==1:
      u.add(i)
  return u
missing_unique(arr,2)

'''Find the maximum product subarray in a given integer array.'''
arr = [-2, 6, -3, -10, 0, 2]
def max_product(arr,n):
  first=arr[0]
  for i in range (n):
    mul=1
    for j in range (i,n):
      mul*=arr[j]
      first= max(mul,first)
  return first
max_product(arr,len(arr))

'''Rotate an array to the right by k steps.'''
def right(arr,k):
  for _ in range(k):
    arr.insert(1,arr.pop())
  return arr
right(arr,len(arr))

'''Find the frequency of each character of string without using inbuilt
methods'''

def freq(s):
  sd=dict()
  for char in s:
    if char not in sd:
      sd[char]=1
    else:
      sd[char]+=1
  return sd
s='Gaurav Patel '

freq(s)

'''Write a Python program to reverse the order of the items in the array.
Sample Output
Original array: array('i', [1, 3, 5, 3, 7, 1, 9, 3])
Reverse the order of the items:
array('i', [3, 9, 1, 7, 3, 5, 3, 1])'''

arr=[1, 3, 5, 3, 7, 1, 9, 3]
def rev_nochange(arr,n):
  for i in range(n//2):
    arr[i],arr[n-i-1]=arr[n-i-1],arr[i]
  return arr
rev_nochange(arr,len(arr))

'''7. Write a Python program to get the number of occurrences of a specified
element in an array.
Sample Output:
Original array: array('i', [1, 3, 5, 3, 7, 9, 3])
Number of occurrences of the number 3 in the said array: 3'''

def count_occ(arr,ele):
  count=0
  for i in arr:
    if i==ele:
      count+=1
  return count
count_occ(arr,3)

def swap_fs_ls(num):
  num=str(num)
  new_num=num[-1]+num[1:-1]+num[0]
  return int(new_num)
num=int(input("enter a nnumber"))
swap_fs_ls(num)

'''Write a program to add all the numbers from 1 to a given number

Sample output:
Add 1 to 4: 10
Add 1 to 100: 5050'''


def upto(n):
  nums=[i  for i in range(1,n+1)]
  return sum(nums)
upto(5)

'''Write a program to read an integer n and prints the factorial of n, assume
that n = 10(n can be any number)'''

def factorial(n):
  fact=1
  for i in range(1,n+1):
    fact*=i
  return fact
factorial(10)

'''Write a program to replace all the lower-case letters of a given string
with the corresponding capital letters

Sample Output:
Input String: Vineeta
Output String: VINEETA'''
s='Vineeta'
def capitt(s):
     return s.upper()
capitt(s)

'''Write a program to print Fibonacci series without using recursion and
using recursion.'''

def fibo(f):
  fib=[]
  a,b=0,1
  for _ in range(f):
    a,b=b,a+b
    fib.append(a)
  return fib
fibo(10)

def fibo_upto(n):
  if n==0:
    return 0
  elif n==1:
    return 1
  a,b=0,1
  for _ in range (2,n+1):
    a,b=b,a+b
  return b
fibo_upto(6)

def fib_rec(n):
  if n<=1:
    return n

  else:
    return fib_rec(n-1)+fib_rec(n-2)
fib_rec(10)

'''Longest valid Parentheses
Given a string S consisting of opening and closing parenthesis '(' and ')'.
Find the length of the longest valid parentheses substring.
Input:
First line contains the number of test cases T. Each test case have one
line string S of character '(' and ')' of length N.'''

def longest_valid_parantheses(s):
  brackets=[-1]
  max_len=0

  for i in range(len(s)):
    if s[i]=='(':
      brackets.append(i)
    else:
      brackets.pop()

      if brackets:
        max_len=max(max_len, i-brackets[-1])
      else:
        brackets.append(i)
        break
  return max_len

para=int(input())
for _ in range(para):
  s=input()
  print(longest_valid_parantheses(s))

def find_dup(arr):
  dup={}
  for i in set(arr):
    dup[i]=arr.count(i)
    print(dup)
  for key,values in dup.items():
    if values>1:
      return key
arr=[1,3,2,2,4]
find_dup(arr)

def dupp(arr):
  for i in range(len(arr)-1) :
    if arr[i]==arr[i+1]:
      return arr[i]
arr=[3,5,4,3,6]
dupp(arr)

'''Given an unsorted array of integers, find the length of the longest
consecutive elements sequence.
Input: nums = [100, 4, 200, 1, 3, 2]
Output: 4 (The longest consecutive sequence is [1, 2, 3, 4])
'''
arr = [100, 4, 200, 1, 3, 2]

def longest_consec_subseq(arr):
    if not nums:
        return []

    nums.sort()
    longest_seq = []
    current_seq = [nums[0]]

    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1]:
            continue
        if nums[i] == nums[i - 1] + 1:
            current_seq.append(nums[i])
        else:
            if len(current_seq) > len(longest_seq):
                longest_seq = current_seq
            current_seq = [nums[i]]

    if len(current_seq) > len(longest_seq):
        longest_seq = current_seq

    return longest_seq

nums = [100, 4, 200, 1, 3, 2]
print(longest_consec_subseq(nums))

def reverse_line(line):
    #break it in reverse list
    r_list=line.split()[::-1]
    print("r_list:",r_list)
    r_line=""
    for word in r_list:
        r_line=r_line+" "+word
    return r_line

r_line=reverse_line(input("Enter a line"))
print("Reverse line is:",r_line)

def rev_line(ln):
  rlist=ln.split()[::-1]
  rline=""
  for word in rlist:
    rline=rline+" "+word
  return rline
rev_line(input("enter a line"))

def count_Primes_nums(n):
    ctr = 0
    for num in range(n):
        if num <= 1:
            continue
        for i in range(2, num):
            if (num % i) == 0:
                break
        else:
            ctr += 1

    return ctr

print(count_Primes_nums(5))

def check_letters_in_string(str1, str2):
    return all(char in str1 for char in str2)
test_cases = [
    ("python", "ypth"),
    ("python", "ypths"),
    ("python", "ypthon"),
    ("123456", "01234"),
    ("123456", "1234")
]

for str1, str2 in test_cases:
    print(check_letters_in_string(str1, str2))

def longest_common_prefix(s):
  if not s:
    return ""

  pre=s[0]
  for substring in s[1:]:
    while not substring.startswith(pre):
      pre=pre[:-1]
      if not pre:
        return False
  return pre
s=["flower","flyover"]
longest_common_prefix(s)

def wordBreak(s, wordDict):

    word_set = set(wordDict)

    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break

    return dp[len(s)]

# Test cases
s1 = "applepenapple"
wordDict = ["apple", "pen"]
wordBreak(s1,wordDict)

